1:"$Sreact.fragment"
2:I[39682,["/flow-previews/docs/2165/merge/_next/static/chunks/b2b0a0eaaed5e855.js","/flow-previews/docs/2165/merge/_next/static/chunks/74ce7ac749fdff47.js","/flow-previews/docs/2165/merge/_next/static/chunks/5e014aa10e4e461d.js"],"LayoutCard"]
3:I[39682,["/flow-previews/docs/2165/merge/_next/static/chunks/b2b0a0eaaed5e855.js","/flow-previews/docs/2165/merge/_next/static/chunks/74ce7ac749fdff47.js","/flow-previews/docs/2165/merge/_next/static/chunks/5e014aa10e4e461d.js"],"ColumnLayout"]
4:I[39682,["/flow-previews/docs/2165/merge/_next/static/chunks/b2b0a0eaaed5e855.js","/flow-previews/docs/2165/merge/_next/static/chunks/74ce7ac749fdff47.js","/flow-previews/docs/2165/merge/_next/static/chunks/5e014aa10e4e461d.js"],"Section"]
5:I[39682,["/flow-previews/docs/2165/merge/_next/static/chunks/b2b0a0eaaed5e855.js","/flow-previews/docs/2165/merge/_next/static/chunks/74ce7ac749fdff47.js","/flow-previews/docs/2165/merge/_next/static/chunks/5e014aa10e4e461d.js"],"Heading"]
6:I[579932,["/flow-previews/docs/2165/merge/_next/static/chunks/b2b0a0eaaed5e855.js","/flow-previews/docs/2165/merge/_next/static/chunks/74ce7ac749fdff47.js","/flow-previews/docs/2165/merge/_next/static/chunks/5e014aa10e4e461d.js"],"default"]
b:I[124952,["/flow-previews/docs/2165/merge/_next/static/chunks/98f97f4ff58011e4.js","/flow-previews/docs/2165/merge/_next/static/chunks/8ea50e9e950168dc.js"],"OutletBoundary"]
c:"$Sreact.suspense"
7:T542,"use strict";
const {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];
const {useMDXComponents: _provideComponents} = arguments[0];
function _createMdxContent(props) {
  const _components = {
    p: "p",
    ..._provideComponents(),
    ...props.components
  };
  return _jsxs(_Fragment, {
    children: [_jsx(_components.p, {
      children: "Error- und Loading Boundaries sind ein zentrales Werkzeug, um Ladezustände anzuzeigen und Fehler im UI gezielt abzufangen. Sie verhindern, dass Fehler unkontrolliert die gesamte Anwendung zum Absturz bringen, und bieten die Möglichkeit, Usern eine verständliche Rückmeldung zu geben. Gleichzeitig unterstützen sie Entwicklern durch Logging und Monitoring bei der Fehleranalyse."
    }), "\n", _jsx(_components.p, {
      children: "Da jede Anwendung unterschiedliche Anforderungen hat, gibt es kein universelles Schema, wo und wie Boundaries am besten platziert werden. Die folgenden Best practices sollen bei der Orientierung und Entscheidungsfindung helfen."
    })]
  });
}
function MDXContent(props = {}) {
  const {wrapper: MDXLayout} = {
    ..._provideComponents(),
    ...props.components
  };
  return MDXLayout ? _jsx(MDXLayout, {
    ...props,
    children: _jsx(_createMdxContent, {
      ...props
    })
  }) : _createMdxContent(props);
}
return {
  default: MDXContent
};
8:T5ae7,"use strict";
const {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];
const {useMDXComponents: _provideComponents} = arguments[0];
function _createMdxContent(props) {
  const _components = {
    a: "a",
    code: "code",
    h1: "h1",
    h2: "h2",
    h3: "h3",
    hr: "hr",
    li: "li",
    p: "p",
    pre: "pre",
    strong: "strong",
    table: "table",
    tbody: "tbody",
    td: "td",
    th: "th",
    thead: "thead",
    tr: "tr",
    ul: "ul",
    ..._provideComponents(),
    ...props.components
  }, {Alert, Content, Heading} = _components;
  if (!Alert) _missingMdxReference("Alert", true);
  if (!Content) _missingMdxReference("Content", true);
  if (!Heading) _missingMdxReference("Heading", true);
  return _jsxs(_Fragment, {
    children: [_jsxs(Alert, {
      children: [_jsx(Heading, {
        children: "Guideline für interne Teams"
      }), _jsx(Content, {
        children: _jsx(_components.p, {
          children: "Diese Guideline richtet sich in erster Linie an das interne Team von\nmittwald und setzt entsprechendes Vorwissen voraus. Die darin genannten\nKomponenten beziehen sich auf interne mStudio-Komponenten."
        })
      })]
    }), "\n", _jsx(_components.h1, {
      children: "Technische Umsetzung"
    }), "\n", _jsx(_components.p, {
      children: "Bei der Platzierung der Boundaries empfiehlt es sich, vom Groben ins Detail\nvorzugehen. Entscheidend ist eine gute Balance: Zu viele kleine Boundaries\nerhöhen die Komplexität, zu wenige gefährden hingegen die Stabilität großer\nTeile der Anwendung."
    }), "\n", _jsxs(_components.table, {
      children: [_jsx(_components.thead, {
        children: _jsxs(_components.tr, {
          children: [_jsx(_components.th, {
            children: "Typ"
          }), _jsx(_components.th, {
            children: "Verwendung"
          }), _jsx(_components.th, {
            children: "Element"
          }), _jsx(_components.th, {
            children: "Fehlerfall"
          }), _jsx(_components.th, {
            children: "Loading"
          })]
        })
      }), _jsxs(_components.tbody, {
        children: [_jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            children: _jsx(_components.code, {
              children: "LayoutCard"
            })
          }), _jsx(_components.td, {
            children: "Äußerste Boundary einer Seite"
          }), _jsx(_components.td, {
            children: "LayoutCard"
          }), _jsx(_components.td, {
            children: "LayoutCard mit IllustratedMessage"
          }), _jsx(_components.td, {
            children: "LayoutCard mit Sections mit mehrzeiligen Skeletons"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            children: _jsx(_components.code, {
              children: "LayoutCardFragment"
            })
          }), _jsx(_components.td, {
            children: "Für Dashboards mit ungewisser Anzahl und Breite der Kacheln"
          }), _jsx(_components.td, {
            children: "Fragment"
          }), _jsx(_components.td, {
            children: "LayoutCard mit IllustratedMessage"
          }), _jsx(_components.td, {
            children: "LayoutCard mit Sections mit mehrzeiligen Skeletons"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            children: _jsx(_components.code, {
              children: "SectionsFragment"
            })
          }), _jsx(_components.td, {
            children: "Äußerste Boundary in Tabs"
          }), _jsx(_components.td, {
            children: "Fragment"
          }), _jsx(_components.td, {
            children: "IllustratedMessage"
          }), _jsx(_components.td, {
            children: "Sections mit mehrzeiligen Skeletons"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            children: _jsx(_components.code, {
              children: "Section"
            })
          }), _jsx(_components.td, {
            children: "Ersetzt normale Sections"
          }), _jsx(_components.td, {
            children: "Section"
          }), _jsx(_components.td, {
            children: "Fehler Section"
          }), _jsx(_components.td, {
            children: "Mehrzeilige Skeletons"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            children: _jsx(_components.code, {
              children: "ContentFragment"
            })
          }), _jsx(_components.td, {
            children: "Für mehrzeilige Inhalte"
          }), _jsx(_components.td, {
            children: "Fragment"
          }), _jsx(_components.td, {
            children: "Mehrzeilige Skeletons"
          }), _jsx(_components.td, {
            children: "Mehrzeilige Skeletons"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            children: _jsx(_components.code, {
              children: "Fragment"
            })
          }), _jsx(_components.td, {
            children: "Für Inhalte die im Lade / Fehlerzustand nicht angezeigt werden"
          }), _jsx(_components.td, {
            children: "Fragment"
          }), _jsx(_components.td, {
            children: "Nichts"
          }), _jsx(_components.td, {
            children: "Nichts"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            children: _jsx(_components.code, {
              children: "ContextMenu"
            })
          }), _jsx(_components.td, {
            children: "Ersetzt normale ContextMenus"
          }), _jsx(_components.td, {
            children: "ContextMenu"
          }), _jsx(_components.td, {
            children: "Menu Items mit Skeleton"
          }), _jsx(_components.td, {
            children: "Menu Item mit Fehlertext"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            children: _jsx(_components.code, {
              children: "Modal"
            })
          }), _jsx(_components.td, {
            children: "Ersetzt normale Modals"
          }), _jsx(_components.td, {
            children: "Modal"
          }), _jsx(_components.td, {
            children: "IllustratedMessage"
          }), _jsx(_components.td, {
            children: "LoadingView der Flow Component"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            children: _jsx(_components.code, {
              children: "Text"
            })
          }), _jsx(_components.td, {
            children: "Für Texte"
          }), _jsx(_components.td, {
            children: "Text"
          }), _jsx(_components.td, {
            children: "Fehlertext"
          }), _jsx(_components.td, {
            children: "Einzeiliges Skeleton"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            children: _jsx(_components.code, {
              children: "String"
            })
          }), _jsx(_components.td, {
            children: "Für einzeilige Inhalte"
          }), _jsx(_components.td, {
            children: "Fragment"
          }), _jsx(_components.td, {
            children: "Fehlertext"
          }), _jsx(_components.td, {
            children: "Einzeiliges Skeleton"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            children: _jsx(_components.code, {
              children: "Link"
            })
          }), _jsx(_components.td, {
            children: "Für Links"
          }), _jsx(_components.td, {
            children: "Link"
          }), _jsx(_components.td, {
            children: "Fehlertext"
          }), _jsx(_components.td, {
            children: "Einzeiliges Skeleton"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            children: _jsx(_components.code, {
              children: "Avatar"
            })
          }), _jsx(_components.td, {
            children: "Für Avatare"
          }), _jsx(_components.td, {
            children: "Avatar"
          }), _jsx(_components.td, {
            children: "Leerer Avatar"
          }), _jsx(_components.td, {
            children: "Avatar Skeleton"
          })]
        }), _jsxs(_components.tr, {
          children: [_jsx(_components.td, {
            children: _jsx(_components.code, {
              children: "FieldFragment"
            })
          }), _jsx(_components.td, {
            children: "Für Form Fields mit nachgeladenen Inhalten"
          }), _jsx(_components.td, {
            children: "Fragment"
          }), _jsx(_components.td, {
            children: "Nichts"
          }), _jsx(_components.td, {
            children: "Text Field"
          })]
        })]
      })]
    }), "\n", _jsx(_components.h2, {
      children: "Inhalte einer LayoutCard (WithBoundaries.LayoutCard)"
    }), "\n", _jsxs(_components.p, {
      children: ["Sind Funktionen oder Informationen einer LayoutCard essenziell für die Nutzung\nder Seite, sollte die gesamte LayoutCard mit ", _jsx(_components.code, {
        children: "WithBoundaries.LayoutCard"
      }), "\numschlossen sein."]
    }), "\n", _jsx(_components.p, {
      children: "[Beispiel LayoutCard]"
    }), "\n", _jsx(_components.h2, {
      children: "Inhalte eines Tabs (WithBoundaries.SectionsFragment)"
    }), "\n", _jsxs(_components.p, {
      children: ["Manchmal sind Inhalte einer Seite auf mehrere Tabs verteilt, sodass es sich\nlohnen kann einen Tab seperat zu schützen. Nutze dafür\n", _jsx(_components.code, {
        children: "WithBoundaries.SectionsFragment"
      }), " und gebe eine Anzahl der geladenen Sections\nals SectionsCount mit um entsprechende LoadingView zu steuern. Wird in dem Tab\neine Liste geladen, sollte sie mit dem SectionsCount 1 geladen werden."]
    }), "\n", _jsx(_components.h3, {
      children: "Listenseite"
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsxs(_components.li, {
        children: ["\n", _jsxs(_components.p, {
          children: [_jsx(_components.code, {
            children: "WithBoundaries.LayoutCard"
          }), " mit sectionsCount 1"]
        }), "\n"]
      }), "\n", _jsxs(_components.li, {
        children: ["\n", _jsx(_components.p, {
          children: "Count der Liste wird direkt hier geladen, damit im Fehlerfall die ganze Seite\neine Fehlermeldung zeigt (Liste ist Hauptelement der Seite)"
        }), "\n"]
      }), "\n"]
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {
        children: "export const CronjobsPage: FC = () => (\n  <WithBoundaries.LayoutCard suspenseFallbackProps={{ sectionsCount: 1 }}>\n    {() => {\n      const { projectId } = usePathParams(\"projectId\");\n      const projectGhost = ProjectGhost.ofId(projectId);\n      const cronjobCount = projectGhost.cronjobs.getTotalCount().use();\n\n      return (\n        <>\n          <ProjectDeactivatedAlert project={projectGhost} />\n          <WithBoundaries.Section>\n            {backupCount === 0 ? <CronjobIllustratedMessage project={projectGhost} /> : <CronjobList project={projectGhost} />}\n          </WithBoundaries.Section>\n        </>\n      );\n    }}\n  </WithBoundaries.LayoutCard>\n);\n"
      })
    }), "\n", _jsx(_components.h3, {
      children: "Detailseite / Tab"
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsxs(_components.li, {
        children: ["\n", _jsxs(_components.p, {
          children: [_jsx(_components.code, {
            children: "WithBoundaries.LayoutCard"
          }), " / ", _jsx(_components.code, {
            children: "WithBoundaries.SectionsFragment"
          }), " mit\nSectionCount, je nach Anzahl der auf jeden Fall geladenen Sections"]
        }), "\n"]
      }), "\n", _jsxs(_components.li, {
        children: ["\n", _jsx(_components.p, {
          children: "Cronjob wird als Hauptelement der Seite hier geladen, damit im Fehlerfall die\nganze Seite eine Fehlermeldung zeigt"
        }), "\n"]
      }), "\n"]
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {
        children: "export const CronjobPage: FC = () => (\n  <WithBoundaries.LayoutCard suspenseFallbackProps={{ sectionsCount: 3 }}>\n    {() => {\n      const { cronjobId } = usePathParams(\"cronjobId\");\n      const cronjob = CronjobGhost.ofId(cronjobId).getCommon().use();\n\n      return (\n        <>\n          <ProjectDeactivatedAlert project={cronjob.project} />\n          <GeneralSection cronjob={cronjob} />\n          <IntervalSection cronjob={cronjob} />\n        </>\n      );\n    }}\n  </WithBoundaries.LayoutCard>\n);\n"
      })
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {
        children: "export const CronjobTabs: FC = () => (\n  <LayoutCard>\n    <Tabs>\n      <Tab>\n        <TabTitle>Allgemein</TabTitle>\n        <WithBoundaries.SectionsFragment suspenseFallbackProps={{ sectionsCount: 3 }}>\n          {() => {\n            const { cronjobId } = usePathParams(\"cronjobId\");\n            const cronjob = CronjobGhost.ofId(cronjobId).getCommon().use();\n\n            return (\n              <>\n                <ProjectDeactivatedAlert project={cronjob.project} />\n                <GeneralSection cronjob={cronjob} />\n                <IntervalSection cronjob={cronjob} />\n              </>\n            );\n          }}\n        </WithBoundaries.SectionsFragment>\n      </Tab>\n    </Tabs>\n  </LayoutCard>\n);\n"
      })
    }), "\n", _jsx(_components.h2, {
      children: "Inhalte von Forms in Modals (WithBoundaries.Modal)"
    }), "\n", _jsxs(_components.p, {
      children: ["Eine teilweise geladene oder fehlerhafte Form untergräbt das Vertrauen der User\nund kann zu unvollständigen oder inkonsistenten Daten führen. Daher sollte eine\nForm immer mithilfe von ", _jsx(_components.code, {
        children: "WithBoundaries.Modal"
      }), " geschützt werden. Sobald\ninnerhalb der Form ein Fehler aufftritt, fällt das automatisch das ganze Modal\nin eine Error-View, auch wenn es darin noch Boundaries gibt."]
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {
        children: "interface Props {\n  cronjob:CronjobProxy;\n  controller?: OverlayController;\n}\n\nexport const RenameCronjobModal: FC<Props> = (props) => (\n  <WithBoundaries.Modal controller={props.controller}>\n    {() => {\n      const { cronjobProxy } = asProxyProps(props, [\"cronjob\"]);\n      const controller = useOverlayController(\"Modal\");\n      const form = useForm();\n      const handleOnSubmit = async () => {\n        ...\n        controller.close();\n      };\n\n      return (\n        <Form form={form} onSubmit={handleOnSubmit}>\n          ...\n        </Form>\n      );\n    }}\n  </WithBoundaries.Modal>\n);\n"
      })
    }), "\n", _jsx(_components.h2, {
      children: "Inhalte einzelner Sections (WithBoundaries.Section)"
    }), "\n", _jsxs(_components.p, {
      children: ["Eine Section kann ergänzende Informationen oder Funktionen aus einem anderen\nService enthalten, die das primäre Nutzererlebnis der Seite nicht einschränken.\nIn solchen Fällen lohnt sich eine Abgrenzung über ", _jsx(_components.code, {
        children: "WithBoundaries.Section"
      }), ". So\nbleiben Fehler auf einen kleinen Bereich beschränkt, ohne die gesamte Seite zu\ngefährden."]
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {
        children: "export const GeneralSection: FC<Props> = (props) => (\n  <WithBoundaries.Section>\n    {() => {\n      const { cronjobGhost } = asGhostProps(props);\n      const cronjob = cronjobGhost.getCommon().use();\n      const t = useTCronjob();\n\n      return (\n        <>\n          <Heading>{t(\"cronjob\")}</Heading>\n          ...\n        </>\n      );\n    }}\n  </WithBoundaries.Section>\n);\n"
      })
    }), "\n", _jsxs(_components.p, {
      children: [_jsx(_components.strong, {
        children: "Sonderfall:"
      }), " Manche Sections werden nur unter bestimmten Bedingungen\nangezeigt. In diesen Situationen soll keine eigene Loading-View erzeugt werden,\ndamit Nutzer kein Ladeverhalten sehen, das später nicht zu einem sichtbaren\nErgebnis führt. Für solche Fälle eignet sich ", _jsx(_components.code, {
        children: "WithBoundaries.Fragment"
      }), ", da es\ndie Section schützt, ohne einen sichtbaren Ladezustand zu erzeugen."]
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {
        children: "export const AppInstallationSection: FC<Props> = (props) => (\n  <WithBoundaries.Fragment>\n    {() => {\n      const { cronjobGhost } = asGhostProps(props);\n      const cronjob = cronjobGhost.getCommon().use();\n      const t = useTCronjob();\n\n      if(!cronjob.linkedAppInstallation){\n        return null;\n      }\n\n      return (\n        <Section>...</Section>\n      );\n    }}\n  </WithBoundaries.Fragment>\n);\n"
      })
    }), "\n", _jsx(_components.h2, {
      children: "Inhalte eines Diagramms (WIP)"
    }), "\n", _jsxs(_components.p, {
      children: ["Diagramme beziehen in der Regel viele Daten aus externen Service und sind daher\nfehleranfällig. Sie sollten immer separat von einer Boundary umschlossen werden.\nDiagramm-Komponenten wie das ", _jsx(_components.code, {
        children: "CartesianChart"
      }), " besitzen eine eigene Error-View.\nIst das nicht der Fall, sollte mindestens die Section des Diagramms mit einer\nBoundary abgesichert werden."]
    }), "\n", _jsx(_components.p, {
      children: "[Code-Beispiele??]"
    }), "\n", _jsx(_components.h2, {
      children: "Inhalte einzelner kleinerer Elemente"
    }), "\n", _jsx(_components.p, {
      children: "Kleine Ergänzungen wie Texte, Links, ContextMenus, Badges oder Actions werden\noft dynamisch geladen. Diese sollten ebenfalls seperat geschützt werden, um\nnicht die gesamte Seite zu blockieren. Da diese Elemente keine eigene Error-View\nbesitzen, erscheinen sie im Fehlerfall nicht oder verbleiben im Ladezustand."
    }), "\n", _jsx(_components.h3, {
      children: "Texte"
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {
        children: "<LabeledValue>\n  <Label>{t(\"projectShortId\")}</Label>\n  <WithBoundaries.Text>\n    {() =>  projectGhost.getCommon().use().shortId }\n  </WithBoundaries.Text>\n</LabeledValue>\n"
      })
    }), "\n", _jsx(_components.p, {
      children: "Zusätzlich gibt es Components die direkt auf ein Model angewendet werden können\nund eine eingebaute Boundary besitzen."
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {
        children: "<ModelLink model={cronjob}>\n  <ModelTitle model={cronjob} />\n</ModelLink>\n\n<ModelLabeledValue model={cronjob}/>\n"
      })
    }), "\n", _jsx(_components.h3, {
      children: "ContextMenu"
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {
        children: "export const ActionsContextMenu: FC<Props> = (props) => {\n  const { cronjobProxy } = asProxyProps(props);\n  const deleteModalController = useOverlayController(\"Modal\");\n\n  return (\n    <>\n      <WithBoundaries.ContextMenu placement=\"bottom end\">\n        {() => {\n          const cronjob = cronjobProxy.getCommon().use();\n          return <DeleteMenuItem onAction={() => deleteModalController.open()} />;\n        }}\n      </WithBoundaries.ContextMenu>\n\n      <DeleteCronjobModal\n        controller={deleteModalController}\n        cronjob={cronjobProxy}\n      />\n    </>\n  );\n};\n"
      })
    }), "\n", _jsx(_components.h3, {
      children: "Alerts / Badges"
    }), "\n", _jsxs(_components.ul, {
      children: ["\n", _jsxs(_components.li, {
        children: ["Alerts und Badges werden in ein ", _jsx(_components.code, {
          children: "WithBoundaries.Fragment"
        }), " verpackt"]
      }), "\n"]
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {
        children: "export const CustomerBankruptAlert: FC<Props> = (props) => (\n  <WithBoundaries.Fragment>\n    {() => {\n      const { customerProxy, asBadge } = asProxyProps(props, [\"customer\"]);\n      const isBankrupt = customerProxy.getDetailed().isBankrupt().use();\n\n      if (!isBankrupt) {\n        return null;\n      }\n\n      if (asBadge) {\n        return <AlertBadge>...</AlertBadge>\n      }\n\n      return <Alert>...</Alert>;\n    }}\n  </WithBoundaries.Fragment>\n);\n"
      })
    }), "\n", _jsx(_components.h3, {
      children: "Field"
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {
        children: "export const AppInstallationSelectField: FC<Props> = (props) => {\n  const { name, label, projectGhost } = asGhostProps(props, [\"project\"]);\n\n  return (\n    <WithBoundaries.FieldFragment suspenseFallbackProps={{ label }}>\n      {() => {\n        const appInstallations = projectGhost.appInstallations.execute().use().items;\n\n        return (\n          <Field name={name}>\n            <Select isDisabled={appInstallations.length === 0}>\n              <Label>{label}</Label>\n              {sortedAppInstallations.map((i) => (\n                <Option key={i.id} value={i.id}>\n                  {i.description}\n                </Option>\n              ))}\n            </Select>\n          </Field>\n        );\n      }}\n    </WithBoundaries.FieldFragment>\n  );\n};\n"
      })
    }), "\n", _jsx(_components.hr, {}), "\n", _jsx(_components.h1, {
      children: "Weitere Empfehlungen"
    }), "\n", _jsxs(_components.p, {
      children: ["Ein durchdachtes Loading und Error-Boundary Konzept endet nicht bei der\ntechnischen Umsetzung. Fehler sollten zuverlässig erfasst und an Monitoring\nSysteme, Sentry oder Datadog weitergegeben werden, damit Probleme früh sichtbar\nwerden. Manuelle und automatisierte Tests helfen dabei, die eigenen Fallbacks\nregelmäßig zu überprüfen und sicherzustellen, dass sie in allen relevanten\nSituationen greifen. Ebenso wichtig ist eine klare und konsistente Formulierung\nder Fehlermeldungen, damit User verstehen, was passiert und wie sie weitermachen\nkönnen. Für konkrete Hinweise zur sprachlichen Ausgestaltung bietet die\nGuideline\n", _jsx(_components.a, {
        href: "/02-foundations/03-content-guidelines/02-fehlermeldungen",
        children: "Writing for Errors"
      }), "\nweitere Orientierung. So entsteht ein stabiles und nachvollziehbares Verhalten,\ndas sowohl die Entwicklung als auch die Nutzung der Anwendung unterstützt."]
    }), "\n", _jsx(_components.pre, {
      children: _jsx(_components.code, {})
    })]
  });
}
function MDXContent(props = {}) {
  const {wrapper: MDXLayout} = {
    ..._provideComponents(),
    ...props.components
  };
  return MDXLayout ? _jsx(MDXLayout, {
    ...props,
    children: _jsx(_createMdxContent, {
      ...props
    })
  }) : _createMdxContent(props);
}
return {
  default: MDXContent
};
function _missingMdxReference(id, component) {
  throw new Error("Expected " + (component ? "component" : "object") + " `" + id + "` to be defined: you likely forgot to import, pass, or provide it.");
}
0:{"buildId":"CRWU-1mYOa49cjcDjWBDF","rsc":["$","$1","c",{"children":[[["$","$L2",null,{"children":["$","$L3",null,{"l":[1],"m":[1],"children":[["$","$L4",null,{"children":[["$","$L5",null,{"level":1,"children":"Boundaries"}],"$undefined","$undefined"]}],["$","$L6",null,{"mdxFile":{"mdxSource":{"compiledSource":"$7","frontmatter":{"title":"Boundaries"},"scope":{}},"examples":{},"slugs":["05-mstudio","01-boundaries"],"filename":"05-mstudio/01-boundaries/index.mdx","anchors":[]}}]]}]}],["$","$L2",null,{"className":"layout-module-scss-module__9bQamG__mainContent","children":["$","$L6",null,{"mdxFile":{"mdxSource":{"compiledSource":"$8","frontmatter":{},"scope":{}},"examples":{},"slugs":["05-mstudio","01-boundaries"],"filename":"05-mstudio/01-boundaries/overview.mdx","anchors":["Technische Umsetzung","Weitere Empfehlungen"]}}]}]],["$L9"],"$La"]}],"loading":null,"isPartial":false}
9:["$","script","script-0",{"src":"/flow-previews/docs/2165/merge/_next/static/chunks/5e014aa10e4e461d.js","async":true}]
a:["$","$Lb",null,{"children":["$","$c",null,{"name":"Next.MetadataOutlet","children":"$@d"}]}]
d:null
